{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dap-mode # Summary # Emacs client/library for Debug Adapter Protocol is a wire protocol for communication between client and Debug Server. It's similar to the LSP but provides integration with debug server. Project status # The API considered unstable until 1.0 release is out. It is tested against Java, Python, Ruby, Elixir and LLDB (C/C++/Objective-C/Swift). Usage # The main entry points are dap-debug and dap-debug-edit-template . The first one asks for a registered debug template and starts the configuration using the default values for that particular configuration. The latter creates a debug template which could be customized before running. dap-debug-edit-template will prepare a template declaration inside a temporary buffer. You should execute this code using C-M-x for the changes to apply. You should also copy this code into your Emacs configuration if you wish to make it persistent. dap-mode also provides a hydra with dap-hydra . You can automatically trigger the hydra when the program hits a breakpoint by using the following code. ( add-hook 'dap-stopped-hook ( lambda ( arg ) ( call-interactively #' dap-hydra ))) Docker usage # You can also use this tool with dockerized debug servers: configure it either with a .dir-locals file or drop an .lsp-docker.yml configuration file (use lsp-docker for general reference). Basically you have one function dap-docker-register that performs all the heavy lifting (finding the original debug template, patching it, registering a debug provider e.t.c). This function examines a configuration file or falls back to the default configuration (which can be patched using the .dir-locals approach, take a note that the default configuration doesn't provide any sane defaults for debugging) and then operates on the combination of the two. This mechanism is the same as in lsp-docker . Note: currently you cannot use this mode when using a network connection to connect to debuggers (this part is yet to be implemented). Still want to talk to debuggers over network? In order to do so you have to look at the launch-args patching done by dap-docker--dockerize-start-file-args , you have to somehow assign nil to dap-server-path before it is passed further into session creation. If you want to stick to a configuration file, take a look at the example below: lsp : server : # 'lsp-docker' fields mappings : - source : \"/your/host/source/path\" # used both by 'lsp-docker' and 'dap-docker' destination : \"/your/local/path/inside/a/container\" # used both by 'lsp-docker' and 'dap-docker' debug : type : docker # only docker is supported subtype : image # or 'container' name : <docker image or container that has the debugger in> # you can omit this field # in this case the 'lsp-docker' ('server' section) image name is used enabled : true # you can explicitly disable 'dap-docker' by using 'false' provider : <your default language debug provider, double quoted string> template : <your default language debug template, double quoted string> launch_command : <an explicit command if you want to override a default one provided by the debug provider> # e.g. if you have installed a debug server in a different directory, not used with 'container' subtype debuggers Features # Configuration # Gallery # Extending DAP with new Debug servers # Links # Debug Adapter Protocol LSP Java Debug Adapter Protocol Server Implementations Acknowledgments # Daniel Martin - LLDB integration. Kien Nguyen - NodeJS debugger, Edge debuggers, automatic extension installation. Aya Igarashi - Go debugger integration. Nikita Bloshchanevich - launch.json support (+ variable expansion), debugpy support, (with some groundwork by yyoncho) runInTerminal support, various bug fixes. Andrei Mochalov - Docker (debugging in containers) integration.","title":"Home"},{"location":"#dap-mode","text":"","title":"dap-mode"},{"location":"#summary","text":"Emacs client/library for Debug Adapter Protocol is a wire protocol for communication between client and Debug Server. It's similar to the LSP but provides integration with debug server.","title":"Summary"},{"location":"#project-status","text":"The API considered unstable until 1.0 release is out. It is tested against Java, Python, Ruby, Elixir and LLDB (C/C++/Objective-C/Swift).","title":"Project status"},{"location":"#usage","text":"The main entry points are dap-debug and dap-debug-edit-template . The first one asks for a registered debug template and starts the configuration using the default values for that particular configuration. The latter creates a debug template which could be customized before running. dap-debug-edit-template will prepare a template declaration inside a temporary buffer. You should execute this code using C-M-x for the changes to apply. You should also copy this code into your Emacs configuration if you wish to make it persistent. dap-mode also provides a hydra with dap-hydra . You can automatically trigger the hydra when the program hits a breakpoint by using the following code. ( add-hook 'dap-stopped-hook ( lambda ( arg ) ( call-interactively #' dap-hydra )))","title":"Usage"},{"location":"#docker-usage","text":"You can also use this tool with dockerized debug servers: configure it either with a .dir-locals file or drop an .lsp-docker.yml configuration file (use lsp-docker for general reference). Basically you have one function dap-docker-register that performs all the heavy lifting (finding the original debug template, patching it, registering a debug provider e.t.c). This function examines a configuration file or falls back to the default configuration (which can be patched using the .dir-locals approach, take a note that the default configuration doesn't provide any sane defaults for debugging) and then operates on the combination of the two. This mechanism is the same as in lsp-docker . Note: currently you cannot use this mode when using a network connection to connect to debuggers (this part is yet to be implemented). Still want to talk to debuggers over network? In order to do so you have to look at the launch-args patching done by dap-docker--dockerize-start-file-args , you have to somehow assign nil to dap-server-path before it is passed further into session creation. If you want to stick to a configuration file, take a look at the example below: lsp : server : # 'lsp-docker' fields mappings : - source : \"/your/host/source/path\" # used both by 'lsp-docker' and 'dap-docker' destination : \"/your/local/path/inside/a/container\" # used both by 'lsp-docker' and 'dap-docker' debug : type : docker # only docker is supported subtype : image # or 'container' name : <docker image or container that has the debugger in> # you can omit this field # in this case the 'lsp-docker' ('server' section) image name is used enabled : true # you can explicitly disable 'dap-docker' by using 'false' provider : <your default language debug provider, double quoted string> template : <your default language debug template, double quoted string> launch_command : <an explicit command if you want to override a default one provided by the debug provider> # e.g. if you have installed a debug server in a different directory, not used with 'container' subtype debuggers","title":"Docker usage"},{"location":"#features","text":"","title":"Features"},{"location":"#configuration","text":"","title":"Configuration"},{"location":"#gallery","text":"","title":"Gallery"},{"location":"#extending-dap-with-new-debug-servers","text":"","title":"Extending DAP with new Debug servers"},{"location":"#links","text":"Debug Adapter Protocol LSP Java Debug Adapter Protocol Server Implementations","title":"Links"},{"location":"#acknowledgments","text":"Daniel Martin - LLDB integration. Kien Nguyen - NodeJS debugger, Edge debuggers, automatic extension installation. Aya Igarashi - Go debugger integration. Nikita Bloshchanevich - launch.json support (+ variable expansion), debugpy support, (with some groundwork by yyoncho) runInTerminal support, various bug fixes. Andrei Mochalov - Docker (debugging in containers) integration.","title":"Acknowledgments"},{"location":"CHANGELOG/","text":"Changelog # Unreleased 0.9 # Added dap-gdb 0.8 # [Breaking Change] Change debug provider names to match VS Code's naming: lldb to lldb-mi and codelldb to lldb Added dap-gdscript Drop support for emacs 26.x 0.7 # [Breaking change] For dap-lldb.el , change type to lldb-vscode . 0.5 # added support for running TestNG tests added dap-auto-configure-mode as the new dap-mode integration point. Migrated to lsp-protocol.el . 0.3 # Added node/go/chrome/firefox/php/ruby/elixir/go/LLDB debuggers support Added support for mouse hover Added automatic installation of debuggers 0.2 # Added python support Added dap-hydra Added dap-ui-repl Bug fixing. v0.1 # Support for managing breakpoints Next/StepIn/StepOut operations Sessions window Inspections Evaluating Breakpoint persistence and session management","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#unreleased-09","text":"Added dap-gdb","title":"Unreleased 0.9"},{"location":"CHANGELOG/#08","text":"[Breaking Change] Change debug provider names to match VS Code's naming: lldb to lldb-mi and codelldb to lldb Added dap-gdscript Drop support for emacs 26.x","title":"0.8"},{"location":"CHANGELOG/#07","text":"[Breaking change] For dap-lldb.el , change type to lldb-vscode .","title":"0.7"},{"location":"CHANGELOG/#05","text":"added support for running TestNG tests added dap-auto-configure-mode as the new dap-mode integration point. Migrated to lsp-protocol.el .","title":"0.5"},{"location":"CHANGELOG/#03","text":"Added node/go/chrome/firefox/php/ruby/elixir/go/LLDB debuggers support Added support for mouse hover Added automatic installation of debuggers","title":"0.3"},{"location":"CHANGELOG/#02","text":"Added python support Added dap-hydra Added dap-ui-repl Bug fixing.","title":"0.2"},{"location":"CHANGELOG/#v01","text":"Support for managing breakpoints Next/StepIn/StepOut operations Sessions window Inspections Evaluating Breakpoint persistence and session management","title":"v0.1"},{"location":"page/adding-debug-server/","text":"Extending DAP with new Debug servers # There are two methods that are used for registering remote extensions: dap-register-debug-provider - register a method to call for populating startup parameters. It should either populate :debugPort and :host in case of TCP Debug Adapter Server or :dap-server-path when STD out must be used for Debug Adapter Server communication. dap-register-debug-template register a debug template which will be available when dap-debug is called. The debug template must specify :type key which will be used to determine the provider to be called to populate missing fields. Example For full example you may check dap-java.el . ( dap-register-debug-provider \"programming-language-name\" ( lambda ( conf ) ( plist-put conf :debugPort 1234 ) ( plist-put conf :host \"localhost\" ) conf )) ( dap-register-debug-template \"Example Configuration\" ( list :type \"java\" :request \"launch\" :args \"\" :name \"Run Configuration\" ))","title":"Adding a new debug server"},{"location":"page/adding-debug-server/#extending-dap-with-new-debug-servers","text":"There are two methods that are used for registering remote extensions: dap-register-debug-provider - register a method to call for populating startup parameters. It should either populate :debugPort and :host in case of TCP Debug Adapter Server or :dap-server-path when STD out must be used for Debug Adapter Server communication. dap-register-debug-template register a debug template which will be available when dap-debug is called. The debug template must specify :type key which will be used to determine the provider to be called to populate missing fields. Example For full example you may check dap-java.el . ( dap-register-debug-provider \"programming-language-name\" ( lambda ( conf ) ( plist-put conf :debugPort 1234 ) ( plist-put conf :host \"localhost\" ) conf )) ( dap-register-debug-template \"Example Configuration\" ( list :type \"java\" :request \"launch\" :args \"\" :name \"Run Configuration\" ))","title":"Extending DAP with new Debug servers"},{"location":"page/clojure/","text":"Clojure debugging and introspecting Java Code # One of the limitations of Cider is that it does not support debugging Java(or it is not very easy to do so). This page provides information on how to do that using dap-mode As a bonus, it will also enable navigation through java code like finding definitions, references, implementations, etc. Java code navigation # Follow the guides on installing lsp-java . If you are Spacemacs user you need to add the following layers dap , lsp , (lsp-java :variables java-backend 'lsp) . lsp-java automatically downloads all required server-side components( JDT Language Server , Java Debug Adapter and JUnit Test Runner ). Go to the root of your project and do lein pom Open a file from your project and do C-u - M-x - lsp which will prompt you to select a server to start, select jdtls server. Once the server has started(the initialization may take some time since JDT LS is downloading sources) you may call xref-appropos and open type a Java Type like ArrayList or PersistentList . When you are in java file you can inspect documentation, look for class implementations, references and so on. Invoke xref-apropos , type a Java class name and then you can set breakpoints, go to definitions, find references, etc. Implementations of clojure.lang.IReduce # Debugging # Configure cider to start nrepl with remote debugging enabled and do cider-jack-in ( setenv \"JAVA_OPTS\" \"-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044\" ) Call dap-debug and select Java Attach configuration and enter port 1044 (the same port as the port above.). Go to java class and place a breakpoint using dap-breakpoint-toggle . Debugging in progress #","title":"Clojure"},{"location":"page/clojure/#clojure-debugging-and-introspecting-java-code","text":"One of the limitations of Cider is that it does not support debugging Java(or it is not very easy to do so). This page provides information on how to do that using dap-mode As a bonus, it will also enable navigation through java code like finding definitions, references, implementations, etc.","title":"Clojure debugging and introspecting Java Code"},{"location":"page/clojure/#java-code-navigation","text":"Follow the guides on installing lsp-java . If you are Spacemacs user you need to add the following layers dap , lsp , (lsp-java :variables java-backend 'lsp) . lsp-java automatically downloads all required server-side components( JDT Language Server , Java Debug Adapter and JUnit Test Runner ). Go to the root of your project and do lein pom Open a file from your project and do C-u - M-x - lsp which will prompt you to select a server to start, select jdtls server. Once the server has started(the initialization may take some time since JDT LS is downloading sources) you may call xref-appropos and open type a Java Type like ArrayList or PersistentList . When you are in java file you can inspect documentation, look for class implementations, references and so on. Invoke xref-apropos , type a Java class name and then you can set breakpoints, go to definitions, find references, etc.","title":"Java code navigation"},{"location":"page/clojure/#implementations-of-clojurelangireduce","text":"","title":"Implementations of clojure.lang.IReduce"},{"location":"page/clojure/#debugging","text":"Configure cider to start nrepl with remote debugging enabled and do cider-jack-in ( setenv \"JAVA_OPTS\" \"-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1044\" ) Call dap-debug and select Java Attach configuration and enter port 1044 (the same port as the port above.). Go to java class and place a breakpoint using dap-breakpoint-toggle .","title":"Debugging"},{"location":"page/clojure/#debugging-in-progress","text":"","title":"Debugging in progress"},{"location":"page/configuration/","text":"Configuration # DAP mode configuration # For an auto-configuration enable the dap-auto-configure-mode . You can configure which features from dap-mode do you want with dap-auto-configure-features : ;; Enabling only some features ( setq dap-auto-configure-features ' ( sessions locals controls tooltip )) Or if you want to enable only specific modes instead: ( dap-mode 1 ) ;; The modes below are optional ( dap-ui-mode 1 ) ;; enables mouse hover support ( dap-tooltip-mode 1 ) ;; use tooltips for mouse hover ;; if it is not enabled `dap-mode' will use the minibuffer. ( tooltip-mode 1 ) ;; displays floating panel with debug buttons ;; requies emacs 26+ ( dap-ui-controls-mode 1 ) After enabling DAP mode on emacs side follow the language specific settings. Java # Installation Latest version of LSP Java will automatically discover if dap-mode is present and it will download and install the required server side components. If you have already downloaded a Eclispe JDT Server you will have to force a server update via C-u M-x lsp-install-server and select \"jdtls\". In order to enable lsp java, you will have to require dap-java.el . ( require 'dap-java ) Commands Command Description dap-java-debug Debug java dap-java-run-test-method Run test method dap-java-debug-test-method Debug test method dap-java-run-test-class Run test class dap-java-debug-test-class Debug test class You can also edit one of the existing templates and execute it with dap-debug . dap-mode will take care of filling missing values, such as classpath. JVM arguments can be specified with :vmArgs : ( dap-register-debug-template \"My Runner\" ( list :type \"java\" :request \"launch\" :args \"\" :vmArgs \"-ea -Dmyapp.instance.name=myapp_1\" :projectName \"myapp\" :mainClass \"com.domain.AppRunner\" :env ' (( \"DEV\" . \"1\" )))) Kotlin # Installation To use dap-mode with Kotlin, you need to download the kotlin-debug-adapter . The releases are a bit infrequent, so it is recommended to build it from source yourself. You will also need to have installed lsp-mode , as dap-kotlin shares some configuration with it. After building it, point the variable lsp-kotlin-debug-adapter-path to the path of the kotlin-debug-adapter executable. You will find this in the path adapter/build/install/adapter/bin (from the kotlin-debug-adapter root). You should also make sure that lsp-kotlin-debug-adapter-enabled is set to true. Usage First of all, each time you you want to debug, make sure you BUILD YOUR PROJECT FIRST! Simply running your regular build with Maven or Gradle should be enough. You can set up debug templates using Kotlin. dap-kotlin provides some sensible defaults, but there are one parameters you MUST give yourself: - :mainClass : The class name, including package for the main class you want to run. If the class takes argument, you can give them as well. If project root path needs to be different, you can give it using the parameter :projectRoot . Other parameters include: - :type : launch or attach - :hostName : If type is attach , you can specify a hostname to connect to. Defaults to localhost . - :port : If type is attach , you can specify a port to connect to. Defaults to 5005 . - :noDebug : Whether or not to use a debug session - :enableJsonLogging : Enable logging of adapter communication logs. - :jsonLogFile : File to log to. Thanks to interop with lsp-kotlin , you can have it set up code lenses with run/debug-options for main classes. For this to work, you need kotlin-langauge-server running, be in a file with a main method, and have activated lsp-kotlin-lens-mode Sadly, there is no test-running functionality like in Java dap-mode . This can be combated by setting up a debug template with the Junit5 ConsoleLauncher . Remember that this class needs to be part of your classpath. Sometimes this is included in bigger frameworks testing utilities, but can also be included explicitly by adding the junit-platform-console dependency. ( dap-register-debug-template \"Kotlin tests with launcher\" ( list :type \"kotlin\" :request \"launch\" :mainClass \"org.junit.platform.console.ConsoleLauncher --scan-class-path\" :enableJsonLogging nil :noDebug nil )) This will run all tests in the projects in debug mode, with no json logging. You can experiment with the arguments to ConsoleLauncher . Arguments are documented on the official JUnit website . Python # Installation Make sure to install the required modules in the project's virtual environment (if any). install debugpy pip install \"debugpy\" Or install ptvsd pip install \"ptvsd>=4.2\" NOTE: ptvsd is depracated, and as of 8/10/2022, ptvsd caused dap to break when it hits a breakpoint. This comment and issue has context: https://github.com/emacs-lsp/dap-mode/issues/625#issuecomment-1128961454 Then add the following line in your config: ( require 'dap-python ) ;; if you installed debugpy, you need to set this ;; https://github.com/emacs-lsp/dap-mode/issues/306 ( setq dap-python-debugger 'debugpy ) This will add the python related configuration to dap-debug . Usage A template named \"Python :: Run Configuration\" will appear, which will execute the currently visited module. This will fall short whenever you need to specify arguments, environment variables or execute a setuptools based script. In such case, define a template: ( dap-register-debug-template \"My App\" ( list :type \"python\" :args \"-i\" :cwd nil :env ' (( \"DEBUG\" . \"1\" )) :target-module ( expand-file-name \"~/src/myapp/.env/bin/myapp\" ) :request \"launch\" :name \"My App\" )) Template parameters These parameters are handled by templates of type python : :target-module : path to some python file to be executed (supersedes :program ) :program : path to some python script/program to be executed (defaults to the buffer's file-name) :module : Python module to be executed using -m \u2026 . If given, this will be added to the argument list in front of program resp. target-module. :args : either a string or a list of strings ( [\"foo\" \"bar\"] ) If a string, it will be split into arguments and shell-unqouted. :debugger : Debugger to use, either \"debugpy\" or \"ptvsd\" (defaults to the value defined in dap-python-debugger ) Remaining parameters are forwarded to the respective debugger. Attach to an existing process dap-python supports also the \"attach\" mode to attach and debug a long running script. A template named \"Python :: Attach to running process\" is also pre-registered for this purpose. ( dap-register-debug-template \"Python :: Attach to running process\" ( list :type \"python\" :request \"attach\" :processId \"${command:pickProcess}\" :name \"Python :: Attach to running process\" )) The ${command:pickProcess} configuration variable used by default to facilitate the user selecting the debug process by a completion popping up window. The real processId can always be specified using its pid . Note : on Linux this is achieved using the ptrace syscall wrapped inside the GDB tool, which means that for distributions that enable YAMA (e.g. Ubuntu) some additional steps may be necessary: Install GDB. Turn on classic ptrace permission sudo sh -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope' Ruby # Download and extract VSCode Ruby Extension . You can do that either by: Calling dap-ruby-setup , the extension will be downloaded and all your path will be automatically set up. Or download the extension manually. Make sure that dap-ruby-debug-program is: (\"node\" path-to-main-js) where node is either \"node\" if nodejs is on the path or path to nodejs and path-to-main-js is full path ./dist/debugger/main.js which is part of the downloaded VScode package. Follow the instructions on installing rdebug-ide from Ruby Debug Installation Put in your emacs configuration. ( require 'dap-ruby ) Dart # LSP Dart has support for debug using dap-mode . You only need to run dap-dart-setup to setup automatically and then you are good to debug dart. Flutter LSP Dart also supports Flutter debug with options to debug a device or emulator. LLDB # Installation LLDB is a debugger that supports, among others, C, C++, Objective-C and Swift. Clone and follow the instructions to compile lldb-vscode from https://github.com/llvm/llvm-project/tree/main/lldb/tools/lldb-vscode Put in your emacs configuration. ( require 'dap-lldb ) Note : For proper Swift support, you need to compile LLDB from https://github.com/apple/swift-lldb and put the compiled LLDB library/framework in the \"extensions\" folder. vscode-cpptools # Installation You only need to run dap-cpptools-setup to setup automatically and then you are good start debugging. - Clone and follow the instructions to compile lldb - vscode from < https : // github . com / llvm / llvm - project / tree / main / lldb / tools / lldb - vscode > - Put in your emacs configuration . ``` elisp ( require 'dap-cpptools) ``` Usage dap-debug-edit-template and select template \"cpptools\" prefixed configuration. Elixir # Make sure that you have properly configured Elixir and that you have Elixir LS binaries on the path and put in your emacs configuration. ( require 'dap-elixir ) Then when you do dap-debug-edit-template and select Elixir which will generate runnable debug configuration. For more details on supported settings by the Elixir Debug Server refer to its documentation. Erlang # Make sure that you have properly configured Erlang and that you have Erlang LS binaries on the path and put in your emacs configuration. ( require 'dap-erlang ) For more information about DAP support in Erlang LS please refer to the official documentation . PHP # Simplify setup of vscode extension with dap-php-setup after requiring dap-php . This is using felixbecker/vscode-php-debug ( downloadable from the marketplace ) as dap-server between emacs and the xdebug-extension on the http-server side. Make sure it is trans/compiled to javascript properly. Only tested under linux with node. ( require 'dap-php ) Start debugging by selecting \"PHP Run Configuration\" from the dap-debug menu, issue the debug request in your browser by choosing the running thread ( dap-switch-thread ) and then dap-step-in . SWI-Prolog # With SWI-Prolog installed , run the following command to build and install the debug adapter executable swipl_debug_adapter : swipl -g \"pack_install(debug_adapter)\" -t halt Add the following line to your Emacs setup: ( require 'dap-swi-prolog ) Run dap-debug in a Prolog buffer and start debugging. Native Debug (GDB/LLDB) # Using https://github.com/WebFreak001/code-debug Configuration For easier of setting up vscode extension, you only need call dap-gdb-lldb-setup after requiring dap-gdb-lldb . Or download and extract VSCode extension (make sure that dap-gdb-lldb-path is pointing to the extract location). ( require 'dap-gdb-lldb ) Then do dap-debug or dap-debug-edit-template and selet GBD or LLDB configuration. Rust # To fully support rust and pretty printing of strings when debugging, remember to add set gdbpath to rust-gdb in your debug template. An example template would be ( dap-register-debug-template \"Rust::GDB Run Configuration\" ( list :type \"gdb\" :request \"launch\" :name \"GDB::Run\" :gdbpath \"rust-gdb\" :target nil :cwd nil )) Go # Installation install gopls Install the delve command by following instructions on delve - installation . install lsp-mode Put in your emacs configuration. ( require 'dap-dlv-go ) Usage assume you have your code at \\~/src/cool/cmd/app/app.go open your main package file e.g \\~/src/cool/cmd/app/app.go or open a test file e.g app test .go add folder to lsp session where your go.mod is or would be M-x lsp-workspace-folders-add \\~/src/cool set break point M-x dap-debug if you want to launch a binary or test to debug, use \"Go Dlv Launch File Configuration\" if you want to debug current test function inside test file use \"Go Dlv Test Current Function Configuration\" if you want to debug current subtest put your cursor on this subtest and use \"Go Dlv Test Current Subtest Configuration\" if you want to debug already running application select \"Go Dlv Attach Configuration\" if you want to debug binary and need to interact with your application, install vterm package and call M-x dap-dlv-go-debug-in-vterm . If you need to add arguments to your command, use C-u M-x dap-dlv-go-debug-in-vterm if you want to debug remote application you need start delve on remote machine first, for example: dlv --headless --accept-multiclient attach 123 -l :1080 (see dlv usage documentation for more command-line options) and select \"Go Dlv Remote Debug\" if your build environment differs from your development environment (for example, you build project inside docker container or in CI pipeline) or you use -trimpath build flag you can use substitutePath . M-x dap-debug-edit-template then select some template and add substitutePath option to it: ( dap-register-debug-template \"Launch Executable trimmed path\" ( list :type \"go\" :request \"launch\" :name \"Launch Executable trimmed path\" :mode \"exec\" :program nil :args nil :env nil :substitutePath ( vector ( ht ( \"from\" \"/home/user/projects/tribonacci\" ) ( \"to\" \"github.com/s-kostyaev/tribonacci\" ))))) and after evaluation you can select this edited template and debug as usual. You also can use dir-locals to save this template for your project. Create .dir-locals.el in root directory of your project: (( go-mode . (( eval . ( progn ( dap-register-debug-template \"Remote debug in docker container\" ( list :type \"go\" :request \"attach\" :name \"Remote debug in docker container\" :mode \"remote\" :substitutePath ( vector ( ht ( \"from\" \"/home/user/projects/tribonacci\" ) ( \"to\" \"/app\" )))))))))) If you need to provide build flags, use :buildFlags key. Trouble shooting put (setq dap-print-io t) and check messages buffer add --log --log-output debugger,rpc,dap to dlv command and check dlv logs e.g linter can return note at debug session response resulting debug session to fail Go (VS Code debug adapter) # This debug adapter is deprecated. Use dap-dlv-go instead. Installation For easier of setting up vscode extension, you only need call dap-go-setup after requiring dap-go . Or manually download and extract VSCode Go Extension .. it is actually zip file. check that you now have .emacs.d/.extension/vscode/golang.go/extension/out/src/debugAdapter/goDebug.js install latest stable nodejs install gopls Install the delve command by following instructions on delve - installation . install lsp-mode Put in your emacs configuration. ( require 'dap-go ) set up hydra hook as instructed above Usage assume you have your code at \\~/src/cool/cmd/app/app.go open your main package file e.g \\~/src/cool/cmd/app/app.go or open a test file e.g app test .go add folder to lsp session where your go.mod is or would be M-x lsp-workspace-folders-add \\~/src/cool set break point M-x dap-debug if you are debugging test files use \"Go Launch File Configuration\" else select e.g \"Go Launch Unoptimized Debug Package Configuration\" Trouble shooting put (setq dap-print-io t) and check messages buffer e.g linter can return note at debug session response resulting debug session to fail Javascript # Firefox Installation For easier of setting up vscode extension, you only need call dap-firefox-setup after requiring dap-firefox . Or manually download and extract VSCode Firefox Debug Extension . Make sure that dap-firefox-debug-program is pointing to the proper file. Put in your configuration file: ( require 'dap-firefox ) Usage dap-debug or dap-debug-edit-template and select the firefox template. For additional documentation on the supported template parameters or about different configuration templates refer to Firefox Debug Adapter . Chrome Installation For easier of setting up vscode extension, you only need call dap-chrome-setup after requiring dap-chrome . Or manually download and extract VSCode Chrome Debug Extension . Make sure that dap-chrome-debug-program is pointing to the proper file. Put in your configuration file: ( require 'dap-chrome ) Usage dap-debug or dap-debug-edit-template and select the chrome template. For additional documentation on the supported template parameters or about different configuration templates refer to Chrome Debug Adapter . Microsoft Edge Installation For easier of setting up vscode extension, you only need call dap-edge-setup after requiring dap-edge . Or manually download and extract VSCode Edge Debug Extension . Make sure that dap-edge-debug-program is pointing to the proper file. Put in your configuration file: ( require 'dap-edge ) Usage dap-debug or dap-debug-edit-template and select the edge template. For additional documentation on the supported template parameters or about different configuration templates refer to Edge Debug Adapter . Node Installation For easier of setting up vscode extension, you only need call dap-node-setup after requiring dap-node . Or manually download and extract VSCode Node Debug Extension . Make sure that dap-node-debug-program is pointing to the proper file. Put in your configuration file: ( require 'dap-node ) Usage dap-debug or dap-debug-edit-template and select the node template. For additional documentation on the supported template parameters or about different configuration templates refer to Nodejs Debugging . Powershell # ( require 'dap-pwsh ) Start debugging by selecting \"Powershell: Launch Script\" from dap-debug menu. Netcoredbg # Netcoredbg is debugger that supports C#, F# and probably other languages of Dotnet platform. ( require 'dap-netcore ) If you have Emacs 26 or older you also need customize dap-netcore-download-url : M-x customize RET dap-netcore-download-url RET Start debugging by selecting \".Net Core Launch (Console)\" or \".Net Core Attach (Console)\" from dap-debug menu. Unity # Installation Automatic Installation: Add dap-unity to your configuration file Call dap-unity-setup to automatically download and extract the debugger If automatic installation fails, see the manual installation steps below Manual Installation: Download the unity-debug extension from the VisualStudio Marketplace Extract the extension contents (Default path: \"{emacsconfigdir}/.extension/vscode/Unity.unity-debug/\") On non-Windows os, the debugger \"{extensiondir}/extension/bin/UnityDebug.exe\" must be flagged as executable Using your favorite terminal: chmod u+x UnityDebug.exe Usage Call dap-debug and select the \"Unity Editor\" template OCaml # earlybird is an OCaml debugger with support for DAP. Installation Install earlybird through opam install earlybird Put in your configuration file: ( require 'dap-ocaml ) Usage Call dap-debug and edit the \"OCaml Debug Template\". Make sure to set the program field as the path of your byte-code compiled program. Note that this debugger only works with bytecode compiled OCaml programs.","title":"Configuration"},{"location":"page/configuration/#configuration","text":"","title":"Configuration"},{"location":"page/configuration/#dap-mode-configuration","text":"For an auto-configuration enable the dap-auto-configure-mode . You can configure which features from dap-mode do you want with dap-auto-configure-features : ;; Enabling only some features ( setq dap-auto-configure-features ' ( sessions locals controls tooltip )) Or if you want to enable only specific modes instead: ( dap-mode 1 ) ;; The modes below are optional ( dap-ui-mode 1 ) ;; enables mouse hover support ( dap-tooltip-mode 1 ) ;; use tooltips for mouse hover ;; if it is not enabled `dap-mode' will use the minibuffer. ( tooltip-mode 1 ) ;; displays floating panel with debug buttons ;; requies emacs 26+ ( dap-ui-controls-mode 1 ) After enabling DAP mode on emacs side follow the language specific settings.","title":"DAP mode configuration"},{"location":"page/configuration/#java","text":"Installation Latest version of LSP Java will automatically discover if dap-mode is present and it will download and install the required server side components. If you have already downloaded a Eclispe JDT Server you will have to force a server update via C-u M-x lsp-install-server and select \"jdtls\". In order to enable lsp java, you will have to require dap-java.el . ( require 'dap-java ) Commands Command Description dap-java-debug Debug java dap-java-run-test-method Run test method dap-java-debug-test-method Debug test method dap-java-run-test-class Run test class dap-java-debug-test-class Debug test class You can also edit one of the existing templates and execute it with dap-debug . dap-mode will take care of filling missing values, such as classpath. JVM arguments can be specified with :vmArgs : ( dap-register-debug-template \"My Runner\" ( list :type \"java\" :request \"launch\" :args \"\" :vmArgs \"-ea -Dmyapp.instance.name=myapp_1\" :projectName \"myapp\" :mainClass \"com.domain.AppRunner\" :env ' (( \"DEV\" . \"1\" ))))","title":"Java"},{"location":"page/configuration/#kotlin","text":"Installation To use dap-mode with Kotlin, you need to download the kotlin-debug-adapter . The releases are a bit infrequent, so it is recommended to build it from source yourself. You will also need to have installed lsp-mode , as dap-kotlin shares some configuration with it. After building it, point the variable lsp-kotlin-debug-adapter-path to the path of the kotlin-debug-adapter executable. You will find this in the path adapter/build/install/adapter/bin (from the kotlin-debug-adapter root). You should also make sure that lsp-kotlin-debug-adapter-enabled is set to true. Usage First of all, each time you you want to debug, make sure you BUILD YOUR PROJECT FIRST! Simply running your regular build with Maven or Gradle should be enough. You can set up debug templates using Kotlin. dap-kotlin provides some sensible defaults, but there are one parameters you MUST give yourself: - :mainClass : The class name, including package for the main class you want to run. If the class takes argument, you can give them as well. If project root path needs to be different, you can give it using the parameter :projectRoot . Other parameters include: - :type : launch or attach - :hostName : If type is attach , you can specify a hostname to connect to. Defaults to localhost . - :port : If type is attach , you can specify a port to connect to. Defaults to 5005 . - :noDebug : Whether or not to use a debug session - :enableJsonLogging : Enable logging of adapter communication logs. - :jsonLogFile : File to log to. Thanks to interop with lsp-kotlin , you can have it set up code lenses with run/debug-options for main classes. For this to work, you need kotlin-langauge-server running, be in a file with a main method, and have activated lsp-kotlin-lens-mode Sadly, there is no test-running functionality like in Java dap-mode . This can be combated by setting up a debug template with the Junit5 ConsoleLauncher . Remember that this class needs to be part of your classpath. Sometimes this is included in bigger frameworks testing utilities, but can also be included explicitly by adding the junit-platform-console dependency. ( dap-register-debug-template \"Kotlin tests with launcher\" ( list :type \"kotlin\" :request \"launch\" :mainClass \"org.junit.platform.console.ConsoleLauncher --scan-class-path\" :enableJsonLogging nil :noDebug nil )) This will run all tests in the projects in debug mode, with no json logging. You can experiment with the arguments to ConsoleLauncher . Arguments are documented on the official JUnit website .","title":"Kotlin"},{"location":"page/configuration/#python","text":"Installation Make sure to install the required modules in the project's virtual environment (if any). install debugpy pip install \"debugpy\" Or install ptvsd pip install \"ptvsd>=4.2\" NOTE: ptvsd is depracated, and as of 8/10/2022, ptvsd caused dap to break when it hits a breakpoint. This comment and issue has context: https://github.com/emacs-lsp/dap-mode/issues/625#issuecomment-1128961454 Then add the following line in your config: ( require 'dap-python ) ;; if you installed debugpy, you need to set this ;; https://github.com/emacs-lsp/dap-mode/issues/306 ( setq dap-python-debugger 'debugpy ) This will add the python related configuration to dap-debug . Usage A template named \"Python :: Run Configuration\" will appear, which will execute the currently visited module. This will fall short whenever you need to specify arguments, environment variables or execute a setuptools based script. In such case, define a template: ( dap-register-debug-template \"My App\" ( list :type \"python\" :args \"-i\" :cwd nil :env ' (( \"DEBUG\" . \"1\" )) :target-module ( expand-file-name \"~/src/myapp/.env/bin/myapp\" ) :request \"launch\" :name \"My App\" )) Template parameters These parameters are handled by templates of type python : :target-module : path to some python file to be executed (supersedes :program ) :program : path to some python script/program to be executed (defaults to the buffer's file-name) :module : Python module to be executed using -m \u2026 . If given, this will be added to the argument list in front of program resp. target-module. :args : either a string or a list of strings ( [\"foo\" \"bar\"] ) If a string, it will be split into arguments and shell-unqouted. :debugger : Debugger to use, either \"debugpy\" or \"ptvsd\" (defaults to the value defined in dap-python-debugger ) Remaining parameters are forwarded to the respective debugger. Attach to an existing process dap-python supports also the \"attach\" mode to attach and debug a long running script. A template named \"Python :: Attach to running process\" is also pre-registered for this purpose. ( dap-register-debug-template \"Python :: Attach to running process\" ( list :type \"python\" :request \"attach\" :processId \"${command:pickProcess}\" :name \"Python :: Attach to running process\" )) The ${command:pickProcess} configuration variable used by default to facilitate the user selecting the debug process by a completion popping up window. The real processId can always be specified using its pid . Note : on Linux this is achieved using the ptrace syscall wrapped inside the GDB tool, which means that for distributions that enable YAMA (e.g. Ubuntu) some additional steps may be necessary: Install GDB. Turn on classic ptrace permission sudo sh -c 'echo 0 > /proc/sys/kernel/yama/ptrace_scope'","title":"Python"},{"location":"page/configuration/#ruby","text":"Download and extract VSCode Ruby Extension . You can do that either by: Calling dap-ruby-setup , the extension will be downloaded and all your path will be automatically set up. Or download the extension manually. Make sure that dap-ruby-debug-program is: (\"node\" path-to-main-js) where node is either \"node\" if nodejs is on the path or path to nodejs and path-to-main-js is full path ./dist/debugger/main.js which is part of the downloaded VScode package. Follow the instructions on installing rdebug-ide from Ruby Debug Installation Put in your emacs configuration. ( require 'dap-ruby )","title":"Ruby"},{"location":"page/configuration/#dart","text":"LSP Dart has support for debug using dap-mode . You only need to run dap-dart-setup to setup automatically and then you are good to debug dart. Flutter LSP Dart also supports Flutter debug with options to debug a device or emulator.","title":"Dart"},{"location":"page/configuration/#lldb","text":"Installation LLDB is a debugger that supports, among others, C, C++, Objective-C and Swift. Clone and follow the instructions to compile lldb-vscode from https://github.com/llvm/llvm-project/tree/main/lldb/tools/lldb-vscode Put in your emacs configuration. ( require 'dap-lldb ) Note : For proper Swift support, you need to compile LLDB from https://github.com/apple/swift-lldb and put the compiled LLDB library/framework in the \"extensions\" folder.","title":"LLDB"},{"location":"page/configuration/#vscode-cpptools","text":"Installation You only need to run dap-cpptools-setup to setup automatically and then you are good start debugging. - Clone and follow the instructions to compile lldb - vscode from < https : // github . com / llvm / llvm - project / tree / main / lldb / tools / lldb - vscode > - Put in your emacs configuration . ``` elisp ( require 'dap-cpptools) ``` Usage dap-debug-edit-template and select template \"cpptools\" prefixed configuration.","title":"vscode-cpptools"},{"location":"page/configuration/#elixir","text":"Make sure that you have properly configured Elixir and that you have Elixir LS binaries on the path and put in your emacs configuration. ( require 'dap-elixir ) Then when you do dap-debug-edit-template and select Elixir which will generate runnable debug configuration. For more details on supported settings by the Elixir Debug Server refer to its documentation.","title":"Elixir"},{"location":"page/configuration/#erlang","text":"Make sure that you have properly configured Erlang and that you have Erlang LS binaries on the path and put in your emacs configuration. ( require 'dap-erlang ) For more information about DAP support in Erlang LS please refer to the official documentation .","title":"Erlang"},{"location":"page/configuration/#php","text":"Simplify setup of vscode extension with dap-php-setup after requiring dap-php . This is using felixbecker/vscode-php-debug ( downloadable from the marketplace ) as dap-server between emacs and the xdebug-extension on the http-server side. Make sure it is trans/compiled to javascript properly. Only tested under linux with node. ( require 'dap-php ) Start debugging by selecting \"PHP Run Configuration\" from the dap-debug menu, issue the debug request in your browser by choosing the running thread ( dap-switch-thread ) and then dap-step-in .","title":"PHP"},{"location":"page/configuration/#swi-prolog","text":"With SWI-Prolog installed , run the following command to build and install the debug adapter executable swipl_debug_adapter : swipl -g \"pack_install(debug_adapter)\" -t halt Add the following line to your Emacs setup: ( require 'dap-swi-prolog ) Run dap-debug in a Prolog buffer and start debugging.","title":"SWI-Prolog"},{"location":"page/configuration/#native-debug-gdblldb","text":"Using https://github.com/WebFreak001/code-debug Configuration For easier of setting up vscode extension, you only need call dap-gdb-lldb-setup after requiring dap-gdb-lldb . Or download and extract VSCode extension (make sure that dap-gdb-lldb-path is pointing to the extract location). ( require 'dap-gdb-lldb ) Then do dap-debug or dap-debug-edit-template and selet GBD or LLDB configuration.","title":"Native Debug (GDB/LLDB)"},{"location":"page/configuration/#rust","text":"To fully support rust and pretty printing of strings when debugging, remember to add set gdbpath to rust-gdb in your debug template. An example template would be ( dap-register-debug-template \"Rust::GDB Run Configuration\" ( list :type \"gdb\" :request \"launch\" :name \"GDB::Run\" :gdbpath \"rust-gdb\" :target nil :cwd nil ))","title":"Rust"},{"location":"page/configuration/#go","text":"Installation install gopls Install the delve command by following instructions on delve - installation . install lsp-mode Put in your emacs configuration. ( require 'dap-dlv-go ) Usage assume you have your code at \\~/src/cool/cmd/app/app.go open your main package file e.g \\~/src/cool/cmd/app/app.go or open a test file e.g app test .go add folder to lsp session where your go.mod is or would be M-x lsp-workspace-folders-add \\~/src/cool set break point M-x dap-debug if you want to launch a binary or test to debug, use \"Go Dlv Launch File Configuration\" if you want to debug current test function inside test file use \"Go Dlv Test Current Function Configuration\" if you want to debug current subtest put your cursor on this subtest and use \"Go Dlv Test Current Subtest Configuration\" if you want to debug already running application select \"Go Dlv Attach Configuration\" if you want to debug binary and need to interact with your application, install vterm package and call M-x dap-dlv-go-debug-in-vterm . If you need to add arguments to your command, use C-u M-x dap-dlv-go-debug-in-vterm if you want to debug remote application you need start delve on remote machine first, for example: dlv --headless --accept-multiclient attach 123 -l :1080 (see dlv usage documentation for more command-line options) and select \"Go Dlv Remote Debug\" if your build environment differs from your development environment (for example, you build project inside docker container or in CI pipeline) or you use -trimpath build flag you can use substitutePath . M-x dap-debug-edit-template then select some template and add substitutePath option to it: ( dap-register-debug-template \"Launch Executable trimmed path\" ( list :type \"go\" :request \"launch\" :name \"Launch Executable trimmed path\" :mode \"exec\" :program nil :args nil :env nil :substitutePath ( vector ( ht ( \"from\" \"/home/user/projects/tribonacci\" ) ( \"to\" \"github.com/s-kostyaev/tribonacci\" ))))) and after evaluation you can select this edited template and debug as usual. You also can use dir-locals to save this template for your project. Create .dir-locals.el in root directory of your project: (( go-mode . (( eval . ( progn ( dap-register-debug-template \"Remote debug in docker container\" ( list :type \"go\" :request \"attach\" :name \"Remote debug in docker container\" :mode \"remote\" :substitutePath ( vector ( ht ( \"from\" \"/home/user/projects/tribonacci\" ) ( \"to\" \"/app\" )))))))))) If you need to provide build flags, use :buildFlags key. Trouble shooting put (setq dap-print-io t) and check messages buffer add --log --log-output debugger,rpc,dap to dlv command and check dlv logs e.g linter can return note at debug session response resulting debug session to fail","title":"Go"},{"location":"page/configuration/#go-vs-code-debug-adapter","text":"This debug adapter is deprecated. Use dap-dlv-go instead. Installation For easier of setting up vscode extension, you only need call dap-go-setup after requiring dap-go . Or manually download and extract VSCode Go Extension .. it is actually zip file. check that you now have .emacs.d/.extension/vscode/golang.go/extension/out/src/debugAdapter/goDebug.js install latest stable nodejs install gopls Install the delve command by following instructions on delve - installation . install lsp-mode Put in your emacs configuration. ( require 'dap-go ) set up hydra hook as instructed above Usage assume you have your code at \\~/src/cool/cmd/app/app.go open your main package file e.g \\~/src/cool/cmd/app/app.go or open a test file e.g app test .go add folder to lsp session where your go.mod is or would be M-x lsp-workspace-folders-add \\~/src/cool set break point M-x dap-debug if you are debugging test files use \"Go Launch File Configuration\" else select e.g \"Go Launch Unoptimized Debug Package Configuration\" Trouble shooting put (setq dap-print-io t) and check messages buffer e.g linter can return note at debug session response resulting debug session to fail","title":"Go (VS Code debug adapter)"},{"location":"page/configuration/#javascript","text":"Firefox Installation For easier of setting up vscode extension, you only need call dap-firefox-setup after requiring dap-firefox . Or manually download and extract VSCode Firefox Debug Extension . Make sure that dap-firefox-debug-program is pointing to the proper file. Put in your configuration file: ( require 'dap-firefox ) Usage dap-debug or dap-debug-edit-template and select the firefox template. For additional documentation on the supported template parameters or about different configuration templates refer to Firefox Debug Adapter . Chrome Installation For easier of setting up vscode extension, you only need call dap-chrome-setup after requiring dap-chrome . Or manually download and extract VSCode Chrome Debug Extension . Make sure that dap-chrome-debug-program is pointing to the proper file. Put in your configuration file: ( require 'dap-chrome ) Usage dap-debug or dap-debug-edit-template and select the chrome template. For additional documentation on the supported template parameters or about different configuration templates refer to Chrome Debug Adapter . Microsoft Edge Installation For easier of setting up vscode extension, you only need call dap-edge-setup after requiring dap-edge . Or manually download and extract VSCode Edge Debug Extension . Make sure that dap-edge-debug-program is pointing to the proper file. Put in your configuration file: ( require 'dap-edge ) Usage dap-debug or dap-debug-edit-template and select the edge template. For additional documentation on the supported template parameters or about different configuration templates refer to Edge Debug Adapter . Node Installation For easier of setting up vscode extension, you only need call dap-node-setup after requiring dap-node . Or manually download and extract VSCode Node Debug Extension . Make sure that dap-node-debug-program is pointing to the proper file. Put in your configuration file: ( require 'dap-node ) Usage dap-debug or dap-debug-edit-template and select the node template. For additional documentation on the supported template parameters or about different configuration templates refer to Nodejs Debugging .","title":"Javascript"},{"location":"page/configuration/#powershell","text":"( require 'dap-pwsh ) Start debugging by selecting \"Powershell: Launch Script\" from dap-debug menu.","title":"Powershell"},{"location":"page/configuration/#netcoredbg","text":"Netcoredbg is debugger that supports C#, F# and probably other languages of Dotnet platform. ( require 'dap-netcore ) If you have Emacs 26 or older you also need customize dap-netcore-download-url : M-x customize RET dap-netcore-download-url RET Start debugging by selecting \".Net Core Launch (Console)\" or \".Net Core Attach (Console)\" from dap-debug menu.","title":"Netcoredbg"},{"location":"page/configuration/#unity","text":"Installation Automatic Installation: Add dap-unity to your configuration file Call dap-unity-setup to automatically download and extract the debugger If automatic installation fails, see the manual installation steps below Manual Installation: Download the unity-debug extension from the VisualStudio Marketplace Extract the extension contents (Default path: \"{emacsconfigdir}/.extension/vscode/Unity.unity-debug/\") On non-Windows os, the debugger \"{extensiondir}/extension/bin/UnityDebug.exe\" must be flagged as executable Using your favorite terminal: chmod u+x UnityDebug.exe Usage Call dap-debug and select the \"Unity Editor\" template","title":"Unity"},{"location":"page/configuration/#ocaml","text":"earlybird is an OCaml debugger with support for DAP. Installation Install earlybird through opam install earlybird Put in your configuration file: ( require 'dap-ocaml ) Usage Call dap-debug and edit the \"OCaml Debug Template\". Make sure to set the program field as the path of your byte-code compiled program. Note that this debugger only works with bytecode compiled OCaml programs.","title":"OCaml"},{"location":"page/features/","text":"Features # Launch/Attach Breakpoints Exceptions Pause & Continue Step In/Out/Over Callstacks Threads Multiple simultaneous debug sessions Evaluating statements Debug/Run configurations (also with launch.json files) Expressions Debugger commands # Command Description dap-breakpoint-toggle Toggle breakpoint at line dap-breakpoint-delete Delete breakpoint at line dap-breakpoint-add Add breakpoint at line dap-breakpoint-condition Set/unset breakpoint condition dap-breakpoint-hit-condition Set/unset breakpoint hit condition dap-breakpoint-log-message Set/unset breakpoint log message dap-eval Eval string dap-eval-region Eval region string dap-eval-thing-at-point Eval symbol at point dap-step-in Debug step in dap-next Debug next dap-step-out Debug step out dap-stop-thread Stop thread dap-restart-frame Restart frame dap-continue Debug continue dap-disconnect Cancel current debug session dap-switch-stack-frame Switch active stack frame dap-switch-thread Switch active thread dap-switch-session Switch active session dap-debug-edit-template Generate run command dap-debug Create and run new configuration using the available templates dap-debug-last Debug previous configuration dap-debug-recent Select configuration to run from the previously started command dap-go-to-output-buffer Go output buffer Windows # Command Description dap-ui-sessions Show active/terminated sessions view dap-ui-locals Show locals view dap-ui-expressions Show expressions view dap-ui-breakpoints Show breakpoints view dap-ui-repl DAP UI REPL Sessions # The session view is shown after invoking dap-ui-sessions . It represents the list of the active sessions. Locals # Locals can be viewed after invoking dap-ui-locals . Expressions # Watch expressions can be viewed after invoking dap-ui-expressions . You could add remove watch expressions via dap-ui-expressions-add and dap-ui-expressions-remove . Breakpoints # Breakpoints can be viewed after invoking dap-ui-breakpoints . Keybindings Command Description Keybindings dap-ui-breakpoints-goto Go to breakpoint under cursor \\<return> dap-ui-breakpoints-delete Delete breakpoint under cursor d dap-ui-breakpoints-delete-selected Delete selected breakpoints D bui-list-mark Mark breakpoint under point m bui-list-unmark Unmark breakpoint under point u bui-list-unmark-all Unmark breakpoint under point U Loaded sources # Loaded sources can be viewed by invoking dap-tm-loaded-sources . DAP debug REPL # DAP provides a debug shell to execute commands when the program has hit breakpoints. The REPL has the same features as regular emacs shells (e.g. command history, C-p/n navigation through history, etc.) in addition to optional company-mode autocompletion. launch.json support # DAP supports launch.json files out of the box, and there is nothing that needs to be enabled. All that needs to be done is to add a launch.json file at the project root or the .vscode directory within the project root and to run dap-debug . All configurations stored in the launch.json will automatically show up in the selection. launch.json files in DAP are just like in VSCode and even support variables. See: launch.json launch.json variables Compiling the project before debugging # Many modern IDEs, for example Eclipse and VSCode ( preLaunchTask ), provide functionality to compile the project before starting the debug session. dap-mode also has such a feature: the :dap-compilation property of launch configurations (\"dap-compilation\" in launch.json ) specifies a shell command that needs to execute successfully before the debug session is started. :dap-compilation-dir can be used to control where the compilation is started. In the future, we want to support VSCode's preLaunchTask instead, but currently there is no tasks.json-compatible task runner for Emacs.","title":"Features"},{"location":"page/features/#features","text":"Launch/Attach Breakpoints Exceptions Pause & Continue Step In/Out/Over Callstacks Threads Multiple simultaneous debug sessions Evaluating statements Debug/Run configurations (also with launch.json files) Expressions","title":"Features"},{"location":"page/features/#debugger-commands","text":"Command Description dap-breakpoint-toggle Toggle breakpoint at line dap-breakpoint-delete Delete breakpoint at line dap-breakpoint-add Add breakpoint at line dap-breakpoint-condition Set/unset breakpoint condition dap-breakpoint-hit-condition Set/unset breakpoint hit condition dap-breakpoint-log-message Set/unset breakpoint log message dap-eval Eval string dap-eval-region Eval region string dap-eval-thing-at-point Eval symbol at point dap-step-in Debug step in dap-next Debug next dap-step-out Debug step out dap-stop-thread Stop thread dap-restart-frame Restart frame dap-continue Debug continue dap-disconnect Cancel current debug session dap-switch-stack-frame Switch active stack frame dap-switch-thread Switch active thread dap-switch-session Switch active session dap-debug-edit-template Generate run command dap-debug Create and run new configuration using the available templates dap-debug-last Debug previous configuration dap-debug-recent Select configuration to run from the previously started command dap-go-to-output-buffer Go output buffer","title":"Debugger commands"},{"location":"page/features/#windows","text":"Command Description dap-ui-sessions Show active/terminated sessions view dap-ui-locals Show locals view dap-ui-expressions Show expressions view dap-ui-breakpoints Show breakpoints view dap-ui-repl DAP UI REPL","title":"Windows"},{"location":"page/features/#sessions","text":"The session view is shown after invoking dap-ui-sessions . It represents the list of the active sessions.","title":"Sessions"},{"location":"page/features/#locals","text":"Locals can be viewed after invoking dap-ui-locals .","title":"Locals"},{"location":"page/features/#expressions","text":"Watch expressions can be viewed after invoking dap-ui-expressions . You could add remove watch expressions via dap-ui-expressions-add and dap-ui-expressions-remove .","title":"Expressions"},{"location":"page/features/#breakpoints","text":"Breakpoints can be viewed after invoking dap-ui-breakpoints . Keybindings Command Description Keybindings dap-ui-breakpoints-goto Go to breakpoint under cursor \\<return> dap-ui-breakpoints-delete Delete breakpoint under cursor d dap-ui-breakpoints-delete-selected Delete selected breakpoints D bui-list-mark Mark breakpoint under point m bui-list-unmark Unmark breakpoint under point u bui-list-unmark-all Unmark breakpoint under point U","title":"Breakpoints"},{"location":"page/features/#loaded-sources","text":"Loaded sources can be viewed by invoking dap-tm-loaded-sources .","title":"Loaded sources"},{"location":"page/features/#dap-debug-repl","text":"DAP provides a debug shell to execute commands when the program has hit breakpoints. The REPL has the same features as regular emacs shells (e.g. command history, C-p/n navigation through history, etc.) in addition to optional company-mode autocompletion.","title":"DAP debug REPL"},{"location":"page/features/#launchjson-support","text":"DAP supports launch.json files out of the box, and there is nothing that needs to be enabled. All that needs to be done is to add a launch.json file at the project root or the .vscode directory within the project root and to run dap-debug . All configurations stored in the launch.json will automatically show up in the selection. launch.json files in DAP are just like in VSCode and even support variables. See: launch.json launch.json variables","title":"launch.json support"},{"location":"page/features/#compiling-the-project-before-debugging","text":"Many modern IDEs, for example Eclipse and VSCode ( preLaunchTask ), provide functionality to compile the project before starting the debug session. dap-mode also has such a feature: the :dap-compilation property of launch configurations (\"dap-compilation\" in launch.json ) specifies a shell command that needs to execute successfully before the debug session is started. :dap-compilation-dir can be used to control where the compilation is started. In the future, we want to support VSCode's preLaunchTask instead, but currently there is no tasks.json-compatible task runner for Emacs.","title":"Compiling the project before debugging"},{"location":"page/gallery/","text":"Gallery # Java # Flutter # Swift # RUST # Go # Javascript # Erlang # SWI-Prolog #","title":"Gallery"},{"location":"page/gallery/#gallery","text":"","title":"Gallery"},{"location":"page/gallery/#java","text":"","title":"Java"},{"location":"page/gallery/#flutter","text":"","title":"Flutter"},{"location":"page/gallery/#swift","text":"","title":"Swift"},{"location":"page/gallery/#rust","text":"","title":"RUST"},{"location":"page/gallery/#go","text":"","title":"Go"},{"location":"page/gallery/#javascript","text":"","title":"Javascript"},{"location":"page/gallery/#erlang","text":"","title":"Erlang"},{"location":"page/gallery/#swi-prolog","text":"","title":"SWI-Prolog"},{"location":"page/how-to/","text":"How to # Activate minor modes when stepping through code # You may want to activate minor modes, e.g. read-only-mode , when the debugger is active in a buffer. If so, you could use a trick like this: ;; -*- lexical-binding: t -*- ( define-minor-mode +dap-running-session-mode \"A mode for adding keybindings to running sessions\" nil nil ( make-sparse-keymap ) ( evil-normalize-keymaps ) ;; if you use evil, this is necessary to update the keymaps ;; The following code adds to the dap-terminated-hook ;; so that this minor mode will be deactivated when the debugger finishes ( when +dap-running-session-mode ( let (( session-at-creation ( dap--cur-active-session-or-die ))) ( add-hook 'dap-terminated-hook ( lambda ( session ) ( when ( eq session session-at-creation ) ( +dap-running-session-mode -1 ))))))) ;; Activate this minor mode when dap is initialized ( add-hook 'dap-session-created-hook '+dap-running-session-mode ) ;; Activate this minor mode when hitting a breakpoint in another file ( add-hook 'dap-stopped-hook '+dap-running-session-mode ) ;; Activate this minor mode when stepping into code in another file ( add-hook 'dap-stack-frame-changed-hook ( lambda ( session ) ( when ( dap--session-running session ) ( +dap-running-session-mode 1 )))) Stop and delete sessions # To kill a running debug session (and its inferior process), use the command M-x dap-disconnect . This will still show it as a dead (grayed out) debug session in dap-ui-sessions , and you will still be able to browse its output. If you want to kill the debug session and remove it from the session list, use M-x dap-delete-session instead. The latter command removes the last debug session (dead or alive) from the session list: if you run dap-disconnect , the last session will be a dead one, which you would remove by running M-x dap-delete-session . Sessions can be selectively deleted by putting the cursor on one of the sessions in dap-ui-sessions and pressing D .","title":"How to"},{"location":"page/how-to/#how-to","text":"","title":"How to"},{"location":"page/how-to/#activate-minor-modes-when-stepping-through-code","text":"You may want to activate minor modes, e.g. read-only-mode , when the debugger is active in a buffer. If so, you could use a trick like this: ;; -*- lexical-binding: t -*- ( define-minor-mode +dap-running-session-mode \"A mode for adding keybindings to running sessions\" nil nil ( make-sparse-keymap ) ( evil-normalize-keymaps ) ;; if you use evil, this is necessary to update the keymaps ;; The following code adds to the dap-terminated-hook ;; so that this minor mode will be deactivated when the debugger finishes ( when +dap-running-session-mode ( let (( session-at-creation ( dap--cur-active-session-or-die ))) ( add-hook 'dap-terminated-hook ( lambda ( session ) ( when ( eq session session-at-creation ) ( +dap-running-session-mode -1 ))))))) ;; Activate this minor mode when dap is initialized ( add-hook 'dap-session-created-hook '+dap-running-session-mode ) ;; Activate this minor mode when hitting a breakpoint in another file ( add-hook 'dap-stopped-hook '+dap-running-session-mode ) ;; Activate this minor mode when stepping into code in another file ( add-hook 'dap-stack-frame-changed-hook ( lambda ( session ) ( when ( dap--session-running session ) ( +dap-running-session-mode 1 ))))","title":"Activate minor modes when stepping through code"},{"location":"page/how-to/#stop-and-delete-sessions","text":"To kill a running debug session (and its inferior process), use the command M-x dap-disconnect . This will still show it as a dead (grayed out) debug session in dap-ui-sessions , and you will still be able to browse its output. If you want to kill the debug session and remove it from the session list, use M-x dap-delete-session instead. The latter command removes the last debug session (dead or alive) from the session list: if you run dap-disconnect , the last session will be a dead one, which you would remove by running M-x dap-delete-session . Sessions can be selectively deleted by putting the cursor on one of the sessions in dap-ui-sessions and pressing D .","title":"Stop and delete sessions"},{"location":"page/python-poetry-pyenv/","text":"Debugging Python when using Poetry and Pyenv # This guide is based on this guide on reddit One seemingly sane stack for Python development is Poetry + Pyenv . To debug a project using poetry, start by running poetry config virtualenvs.in-project true poetry add --group dev debugpy poetry install Then, in emacs-land, install with-venv and add the following snippet wherever you tend to add snippets: ( use-package dap-mode :after lsp-mode :commands dap-debug :hook (( python-mode . dap-ui-mode ) ( python-mode . dap-mode )) :config ( require 'dap-python ) ( setq dap-python-debugger 'debugpy ) ( defun dap-python--pyenv-executable-find ( command ) ( with-venv ( executable-find \"python\" ))) ( add-hook 'dap-stopped-hook ( lambda ( arg ) ( call-interactively #' dap-hydra )))) You should now be able to debug your projects by calling dap-hydra as normal.","title":"Python, debbuging with poetry + pyenv"},{"location":"page/python-poetry-pyenv/#debugging-python-when-using-poetry-and-pyenv","text":"This guide is based on this guide on reddit One seemingly sane stack for Python development is Poetry + Pyenv . To debug a project using poetry, start by running poetry config virtualenvs.in-project true poetry add --group dev debugpy poetry install Then, in emacs-land, install with-venv and add the following snippet wherever you tend to add snippets: ( use-package dap-mode :after lsp-mode :commands dap-debug :hook (( python-mode . dap-ui-mode ) ( python-mode . dap-mode )) :config ( require 'dap-python ) ( setq dap-python-debugger 'debugpy ) ( defun dap-python--pyenv-executable-find ( command ) ( with-venv ( executable-find \"python\" ))) ( add-hook 'dap-stopped-hook ( lambda ( arg ) ( call-interactively #' dap-hydra )))) You should now be able to debug your projects by calling dap-hydra as normal.","title":"Debugging Python when using Poetry and Pyenv"}]}